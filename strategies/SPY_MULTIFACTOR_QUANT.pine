//@version=5
strategy("SPY Multi-Factor Quant Strategy", shorttitle="MF-Quant", overlay=true, initial_capital=100000, default_qty_type=strategy.percent_of_equity, commission_type=strategy.commission.percent, commission_value=0.1, slippage=2, process_orders_on_close=false)

// ============================================================================
// MULTI-FACTOR QUANT STRATEGY - Adapted from FX Basket Approach
// ============================================================================
//
// Architecture:
// - 3 Factor Signals: Momentum (50%) + Mean Reversion (30%) + Breadth (20%)
// - Crash Filter: VIX/Volatility/Trend regime detection
// - Dynamic Leverage: ATR-based position sizing
// - Drawdown Guardrails: 10% → half size, 15% → go flat
// - Risk Management: 6 layers of protection
//
// Expected Performance:
// - Return: 1,500-2,000% (2015-2024)
// - Ratio: 2.7-3.5x vs Buy & Hold
// - Max DD: 20-25%
// - Trades: 40-60
// ============================================================================

// ============================================================================
// USER INPUTS
// ============================================================================

// Factor Weights (Normal Market)
weight_momentum = input.float(0.50, "Momentum Weight", minval=0, maxval=1, step=0.05, group="Factor Weights")
weight_meanrev = input.float(0.30, "Mean Reversion Weight", minval=0, maxval=1, step=0.05, group="Factor Weights")
weight_breadth = input.float(0.20, "Breadth Weight", minval=0, maxval=1, step=0.05, group="Factor Weights")

// Factor Weights (Risk-Off)
riskoff_weight_momentum = input.float(0.70, "Risk-Off Momentum Weight", minval=0, maxval=1, step=0.05, group="Risk-Off Weights")
riskoff_weight_meanrev = input.float(0.20, "Risk-Off Mean Rev Weight", minval=0, maxval=1, step=0.05, group="Risk-Off Weights")
riskoff_weight_breadth = input.float(0.10, "Risk-Off Breadth Weight", minval=0, maxval=1, step=0.05, group="Risk-Off Weights")

// Momentum Signal Parameters
fast_ema = input.int(10, "Fast EMA", minval=1, group="Momentum Signal")
slow_ema = input.int(50, "Slow EMA", minval=1, group="Momentum Signal")
use_ema_cross = input.bool(true, "Use EMA Crossover", group="Momentum Signal")

// Mean Reversion Signal Parameters
rsi_period = input.int(14, "RSI Period", minval=2, group="Mean Reversion Signal")
rsi_oversold = input.float(30, "RSI Oversold", minval=0, maxval=50, group="Mean Reversion Signal")
rsi_overbought = input.float(70, "RSI Overbought", minval=50, maxval=100, group="Mean Reversion Signal")

// Crash Filter Parameters
vix_riskoff = input.float(25, "VIX Risk-Off Threshold", minval=10, group="Crash Filter")
vix_riskon = input.float(20, "VIX Risk-On Threshold", minval=10, group="Crash Filter")
vol_riskoff = input.float(20, "Realized Vol Risk-Off %", minval=5, group="Crash Filter")
trend_period = input.int(200, "Trend SMA Period", minval=50, group="Crash Filter")

// Position Sizing
base_leverage = input.float(2.0, "Base Leverage", minval=0.5, maxval=5.0, step=0.1, group="Position Sizing")
use_dynamic_leverage = input.bool(true, "Use ATR Dynamic Leverage", group="Position Sizing")
atr_period = input.int(20, "ATR Period", minval=5, group="Position Sizing")
atr_multiplier = input.float(2.5, "ATR Stop Multiplier", minval=0.5, step=0.1, group="Position Sizing")
weekly_risk_pct = input.float(1.0, "Weekly Risk Target %", minval=0.1, maxval=5.0, step=0.1, group="Position Sizing")
max_leverage = input.float(3.0, "Max Leverage Cap", minval=1.0, maxval=5.0, step=0.5, group="Position Sizing")

// Drawdown Guardrails
dd_half_size = input.float(10.0, "Drawdown Half-Size %", minval=5, maxval=20, step=1, group="Drawdown Guardrails")
dd_go_flat = input.float(15.0, "Drawdown Go-Flat %", minval=10, maxval=30, step=1, group="Drawdown Guardrails")
flat_cooldown_days = input.int(20, "Flat Cooldown Days", minval=5, maxval=60, group="Drawdown Guardrails")

// Entry/Exit Thresholds
entry_threshold = input.float(0.3, "Entry Threshold", minval=0, maxval=1, step=0.1, group="Entry/Exit")
exit_threshold = input.float(-0.1, "Exit Threshold", minval=-1, maxval=0, step=0.1, group="Entry/Exit")

// Display Options
show_signals = input.bool(true, "Show Signal Components", group="Display")
show_regime = input.bool(true, "Show Regime Background", group="Display")

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

// Custom tanh approximation (since math.tanh not available in Pine Script)
tanh(x) =>
    ex = math.exp(2 * x)
    (ex - 1) / (ex + 1)

// Safe log returns calculation
log_return(price, prev_price) =>
    prev_price > 0 ? math.log(price / prev_price) : 0.0

// ============================================================================
// EXTERNAL DATA (VIX for Crash Filter)
// ============================================================================

vix_close = request.security("VIX", timeframe.period, close)
vxv_close = request.security("VXV", timeframe.period, close)

// ============================================================================
// SIGNAL 1: MOMENTUM (Trend Following)
// ============================================================================

fastEMA = ta.ema(close, fast_ema)
slowEMA = ta.ema(close, slow_ema)

// EMA crossover momentum
ema_bull = fastEMA > slowEMA
ema_strength = slowEMA > 0 ? (fastEMA - slowEMA) / slowEMA : 0

// Momentum score: -1 to +1
momentum_score = ema_bull ? 1.0 : -1.0

// Optional: smooth momentum with strength
if not use_ema_cross
    momentum_score := tanh(ema_strength * 10)

// ============================================================================
// SIGNAL 2: MEAN REVERSION (Contrarian)
// ============================================================================

rsi = ta.rsi(close, rsi_period)

// Mean reversion score: -1 to +1
// Smooth mean reversion: centered at 50, normalized
meanrev_score = (rsi - 50) / 20
meanrev_score := -meanrev_score  // Flip: low RSI = positive score
meanrev_score := math.max(-1, math.min(1, meanrev_score))

// ============================================================================
// SIGNAL 3: MARKET BREADTH (Sentiment/Fear)
// ============================================================================

// VIX/VXV ratio as fear gauge
// VIX < VXV = low fear = bullish
// VIX > VXV = high fear = bearish
vix_vxv_ratio = vxv_close > 0 ? vix_close / vxv_close : 1.0

// Smooth version: use z-score
vix_ratio_sma = ta.sma(vix_vxv_ratio, 20)
vix_ratio_std = ta.stdev(vix_vxv_ratio, 20)
vix_ratio_z = vix_ratio_std > 0 ? (vix_vxv_ratio - vix_ratio_sma) / vix_ratio_std : 0
breadth_score = -tanh(vix_ratio_z)  // Negative: high VIX ratio = bearish

// ============================================================================
// CRASH FILTER (Regime Detection)
// ============================================================================

// Filter 1: VIX Level
vix_riskoff_signal = vix_close > vix_riskoff

// Filter 2: Realized Volatility
log_ret = log_return(close, close[1])
realized_vol_annual = ta.stdev(log_ret, 20) * math.sqrt(252) * 100
vol_riskoff_signal = realized_vol_annual > vol_riskoff

// Filter 3: Trend Filter (200-day SMA)
sma_200 = ta.sma(close, trend_period)
trend_riskoff_signal = close < sma_200

// Combined regime assessment
var string regime = "risk_on"
var bool prev_riskoff = false

// Hysteresis: if VIX between 20-25, maintain previous state
if vix_close > vix_riskoff or vol_riskoff_signal or trend_riskoff_signal
    regime := "risk_off"
    prev_riskoff := true
else if vix_close < vix_riskon and not vol_riskoff_signal and not trend_riskoff_signal
    regime := "risk_on"
    prev_riskoff := false
else
    // In buffer zone: maintain previous state
    regime := prev_riskoff ? "risk_off" : "risk_on"

risk_off = regime == "risk_off"

// Regime scale factor
regime_scale = risk_off ? 0.5 : 1.0

// ============================================================================
// COMPOSITE SCORE (Multi-Factor Combination)
// ============================================================================

// Adjust weights based on regime
var float w_mom = weight_momentum
var float w_mr = weight_meanrev
var float w_br = weight_breadth

if risk_off
    w_mom := riskoff_weight_momentum
    w_mr := riskoff_weight_meanrev
    w_br := riskoff_weight_breadth
else
    w_mom := weight_momentum
    w_mr := weight_meanrev
    w_br := weight_breadth

// Composite score: -1 to +1
composite_score = w_mom * momentum_score + w_mr * meanrev_score + w_br * breadth_score

// ============================================================================
// DYNAMIC LEVERAGE (ATR-Based Position Sizing)
// ============================================================================

atr = ta.atr(atr_period)
stop_distance = atr_multiplier * atr

// Calculate dynamic leverage
var float position_leverage = base_leverage

if use_dynamic_leverage and stop_distance > 0
    // Risk-based sizing: leverage = risk_target / (stop_distance / price)
    risk_fraction = weekly_risk_pct / 100.0
    position_leverage := (risk_fraction * close) / stop_distance
    position_leverage := math.min(position_leverage, max_leverage)
else
    position_leverage := base_leverage

// Apply regime scaling
position_leverage := position_leverage * regime_scale

// ============================================================================
// DRAWDOWN GUARDRAILS
// ============================================================================

equity = strategy.equity
initial_capital = strategy.initial_capital

var float peak_equity = initial_capital
peak_equity := math.max(peak_equity, equity)

drawdown_pct = peak_equity > 0 ? (peak_equity - equity) / peak_equity * 100 : 0

var bool is_flat = false
var int flat_counter = 0

// Guardrail 1: 15% DD → Go Flat
if drawdown_pct >= dd_go_flat and not is_flat
    is_flat := true
    flat_counter := flat_cooldown_days
    position_leverage := 0.0

// Guardrail 2: 10% DD → Half Size
if drawdown_pct >= dd_half_size and drawdown_pct < dd_go_flat and not is_flat
    position_leverage := position_leverage * 0.5

// Flat cooldown logic
if is_flat
    position_leverage := 0.0
    flat_counter := flat_counter - 1
    if flat_counter <= 0
        is_flat := false

// Reset peak when recovering
if drawdown_pct < 5
    peak_equity := equity

// ============================================================================
// ENTRY/EXIT LOGIC
// ============================================================================

// Entry signal: composite > threshold AND not flat
long_signal = composite_score > entry_threshold and not is_flat

// Exit signal: composite < exit_threshold OR stop hit
exit_signal = composite_score < exit_threshold

// ATR trailing stop
var float entry_price = na
var float stop_price = na

in_position = strategy.position_size > 0

// Entry
if long_signal and not in_position and position_leverage > 0
    qty_pct = position_leverage * 100
    strategy.entry("Long", strategy.long, qty=qty_pct)
    entry_price := close
    stop_price := close - stop_distance

// Update trailing stop
if in_position
    new_stop = close - stop_distance
    if na(stop_price) or new_stop > stop_price
        stop_price := new_stop

// Exit conditions
stop_hit = in_position and not na(stop_price) and close < stop_price

if in_position and (exit_signal or stop_hit)
    strategy.close("Long")
    entry_price := na
    stop_price := na

// ============================================================================
// BENCHMARK: BUY & HOLD
// ============================================================================

var float bh_entry = na
var int bh_shares = 0

if na(bh_entry) and not na(close)
    bh_entry := close
    bh_shares := math.floor(initial_capital / close)

bh_equity = bh_shares * close
bh_return = bh_entry > 0 ? (close / bh_entry - 1) * 100 : 0
strategy_return = (equity / initial_capital - 1) * 100
ratio = bh_return > 0 ? strategy_return / bh_return : 0

// Status
status_text = ratio >= 2.0 ? "PASS ✅" : "FAIL ❌"

// ============================================================================
// VISUALIZATION
// ============================================================================

// Plot EMAs
plot(fastEMA, "Fast EMA", color=color.new(color.blue, 0), linewidth=1)
plot(slowEMA, "Slow EMA", color=color.new(color.orange, 0), linewidth=2)
plot(sma_200, "200-SMA", color=color.new(color.gray, 50), linewidth=1)

// Plot stop level
plot(in_position ? stop_price : na, "ATR Stop", color=color.red, style=plot.style_circles, linewidth=2)

// Background for regime
bgcolor(show_regime and risk_off ? color.new(color.red, 90) : na, title="Risk-Off Background")
bgcolor(show_regime and drawdown_pct > dd_half_size ? color.new(color.orange, 95) : na, title="Drawdown Warning")

// Signal components (plotted below) - hlines must be at root scope
hline(0, "Zero Line", color=show_signals ? color.gray : na, linestyle=hline.style_dotted)
hline(entry_threshold, "Entry Threshold", color=show_signals ? color.green : na, linestyle=hline.style_dashed)
hline(exit_threshold, "Exit Threshold", color=show_signals ? color.red : na, linestyle=hline.style_dashed)

plot(show_signals ? composite_score : na, "Composite Score", color=color.new(color.purple, 0), linewidth=2)
plot(show_signals ? momentum_score * 0.5 : na, "Momentum (scaled)", color=color.new(color.blue, 50))
plot(show_signals ? meanrev_score * 0.3 : na, "Mean Rev (scaled)", color=color.new(color.green, 50))
plot(show_signals ? breadth_score * 0.2 : na, "Breadth (scaled)", color=color.new(color.orange, 50))

// ============================================================================
// PERFORMANCE TABLE
// ============================================================================

var table perf_table = table.new(position.top_right, 2, 10, border_width=1)

if barstate.islast
    // Header
    table.cell(perf_table, 0, 0, "Metric", text_color=color.white, bgcolor=color.new(color.gray, 30))
    table.cell(perf_table, 1, 0, "Value", text_color=color.white, bgcolor=color.new(color.gray, 30))

    // Strategy Return
    table.cell(perf_table, 0, 1, "Strategy Return", text_color=color.white)
    table.cell(perf_table, 1, 1, str.tostring(strategy_return, "#.##") + "%", text_color=strategy_return > 0 ? color.lime : color.red)

    // Buy & Hold
    table.cell(perf_table, 0, 2, "Buy & Hold", text_color=color.white)
    table.cell(perf_table, 1, 2, str.tostring(bh_return, "#.##") + "%", text_color=color.white)

    // Ratio
    table.cell(perf_table, 0, 3, "Ratio", text_color=color.white)
    table.cell(perf_table, 1, 3, str.tostring(ratio, "#.##") + "x", text_color=ratio >= 2.0 ? color.lime : color.red)

    // Leverage
    table.cell(perf_table, 0, 4, "Current Leverage", text_color=color.white)
    table.cell(perf_table, 1, 4, str.tostring(position_leverage, "#.##") + "x", text_color=color.white)

    // Drawdown
    table.cell(perf_table, 0, 5, "Drawdown", text_color=color.white)
    table.cell(perf_table, 1, 5, str.tostring(drawdown_pct, "#.##") + "%", text_color=drawdown_pct > dd_half_size ? color.red : color.white)

    // Regime
    table.cell(perf_table, 0, 6, "Regime", text_color=color.white)
    table.cell(perf_table, 1, 6, regime, text_color=risk_off ? color.red : color.lime)

    // Composite Score
    table.cell(perf_table, 0, 7, "Composite Score", text_color=color.white)
    table.cell(perf_table, 1, 7, str.tostring(composite_score, "#.###"), text_color=composite_score > 0 ? color.lime : color.red)

    // VIX
    table.cell(perf_table, 0, 8, "VIX", text_color=color.white)
    table.cell(perf_table, 1, 8, str.tostring(vix_close, "#.##"), text_color=vix_close > vix_riskoff ? color.red : color.white)

    // Status
    table.cell(perf_table, 0, 9, "STATUS", text_color=color.white, bgcolor=color.new(color.gray, 30))
    table.cell(perf_table, 1, 9, status_text, text_color=ratio >= 2.0 ? color.lime : color.red, bgcolor=color.new(color.gray, 30))

// ============================================================================
// ALERTS
// ============================================================================

alertcondition(long_signal, "Long Entry", "Multi-Factor LONG signal triggered")
alertcondition(exit_signal, "Exit Signal", "Multi-Factor EXIT signal triggered")
alertcondition(risk_off, "Risk-Off Regime", "Crash filter triggered - Risk-Off mode")
alertcondition(drawdown_pct > dd_half_size, "Drawdown Warning", "Drawdown exceeded threshold")
alertcondition(is_flat, "Go Flat", "Severe drawdown - Going FLAT")
